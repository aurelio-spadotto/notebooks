import meshio
import numpy as np
from sympy import symbols, Eq, solve, sqrt
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
from ipywidgets import interact
import os

class Mesh:
    def __init__(self, faces, Nfaces, Nfaces_init, coords, Npoints, Npoints_init, cut_faces, side_mask, bnd_mask):
        self.faces  = faces
        self.Nfaces = Nfaces
        self.Nfaces_init = Nfaces_init
        self.coords = coords
        self.Npoints = Npoints
        self.Npoints_init = Npoints_init
        self.cut_faces = cut_faces
        self.side_mask = side_mask
        self.bnd_mask = bnd_mask
        self.gamma_edges = np.array([])
        self.Ndof = self.Npoints


def load_square_mesh(filename):
    """
    Loads and parses a 2D mesh in msh format

    Parameters:
    - filename: path to the mesh file

    Returns:
    - Mesh object
    """
    # LOAD MESH:
    mesh_file_path = filename
    mesh = meshio.read(mesh_file_path)
    # face2node connectivity
    faces = mesh.cells[0].data
    # node coordinates
    coords = mesh.points
    # Add dummy column to host faces with more than 3 vertices
    faces = np.c_[faces, -1*np.ones(faces.shape[0])]
    faces = faces.astype(int)
    # Sizes
    Nfaces_init = faces.shape[0]
    Npoints_init = coords.shape[0]
    Nfaces = Nfaces_init
    Npoints = Npoints_init
    # Mask for elements: 0 if uncut, 1 if cut, 2 if generated by cut
    cut_faces = np.zeros(Nfaces)
    # gamme_edge2face connectivity is created by function break_mesh
    # in/ex mask (0: in, 1: ex, -1: cut cell)
    side_mask = -1*np.ones(Nfaces)
    # boundary mask, code:
    # 0: internal
    # 1: x=-0.5
    # 2: y=-0.5
    # 3: x= 0.5
    # 4: y= 0.5
    bnd_mask = np.zeros(Npoints_init)
    return Mesh (faces, Nfaces, Nfaces_init, coords, Npoints, Npoints_init, cut_faces, side_mask, bnd_mask)
    
def move_critical_points(mesh, rho):
    """
    Displace critical points which are too close to the interface
    (avoid rare but nasty situations of elements not properly cut)
    """
    # get mesh_size
    p1 = mesh.faces[0,0]
    p2 = mesh.faces[0,1]
    h = np.linalg.norm(mesh.coords[p1,:]-mesh.coords[p2,:])
    # loop over points
    for ino in range(mesh.Npoints_init):
        x = mesh.coords[ino,0]
        y = mesh.coords[ino,1]
        radius = np.sqrt(x**2+y**2)
        cos_theta = x/radius
        sin_theta = y/radius
        # If node is close to interface less than 1/10*mesh_size
        if (np.abs(rho-radius)<0.1*h):
            # internal nodes towards interior
            if (radius<rho):
                new_radius = radius - 0.1*h
            if (radius>rho):
                new_radius = radius + 0.1*h
            new_x = new_radius*cos_theta
            new_y = new_radius*sin_theta             
            mesh.coords[ino,0] = new_x
            mesh.coords[ino,1] = new_y
            
def move_critical_points_1D(mesh):
    """
    Displace critical points which are too close to the interface
    (avoid rare but nasty situations of elements not properly cut)
    """
    # get mesh_size
    p1 = mesh.faces[0,0]
    p2 = mesh.faces[0,1]
    h = np.linalg.norm(mesh.coords[p1,:]-mesh.coords[p2,:])
    # minimal distance
    eps = 0.1*h
    # loop over points
    for ino in range(mesh.Npoints_init):
        x = mesh.coords[ino,0]
        # If node is close to interface less than 1/10*mesh_size
        if (np.abs(x)<eps):
            # internal nodes towards interior
            if (x<0):
                new_x = x - eps
            if (x>0):
                new_x = x + eps             
            mesh.coords[ino,0] = new_x


def is_proper(value):
    """
    Checks if value is real and in interval(0,1].

    Parameters:
    - value: numerical value to check

    Returns:
    True or False
    """
    return (value.is_real and abs(value)<=1 and value>0)

def calc_intersection(x1,x2,y1,y2,rho):
    """
    Check if segment on a plane intersects with ball of radius rho.

    Parameters:
    - x1: x coord of point1
    - x2: x coord of point2
    - y1: y coord of point1
    - y2: y coord of point2
    - rho: disk radius

    Returns:
    - True/False
    - intersection position (with 3 coords, for compatibility)
    """
    # Define variables
    x, y, t= symbols('x y t')
    # Equation of the circle centered at the origin
    circle_equation = Eq(x**2 + y**2, rho**2)
    # Parametric equations of the line segment
    segment_x = x1 + (x2 - x1) * t
    segment_y = y1 + (y2 - y1) * t
    # Substitute parametric equations into the circle equation
    circle_intersection = circle_equation.subs({x: segment_x, y: segment_y})
    # Solve the resulting quadratic equation for t
    intersection_points = solve(circle_intersection, t)
    #print("Curvilinear abscissa: ", intersection_points)
    if (len(intersection_points)==0):
        return [False, np.array([0.0,0.0,0.0])]
       # Evaluate the parametric equations at the intersection points
    intersection_coordinates = \
       [(segment_x.subs(t, point), segment_y.subs(t, point)) for point in intersection_points]
    #print ("Intersection points: ", intersection_coordinates)
    if (is_proper(intersection_points[0])):
        #print ("it's the first")
        point = intersection_coordinates[0]
        return [True, np.array([point[0], point[1],0.0])]
    elif (is_proper(intersection_points[1])):
        #print ("it's the second")
        point = intersection_coordinates[1]
        return [True, np.array([point[0], point[1],0.0])]
    else:
        return [False, np.array([0.0,0.0,0.0])]
        
def calc_intersection_1D(x1,x2,y1,y2):
    """
    Check if segment on a plane intersects line x=0

    Parameters:
    - x1: x coord of point1
    - x2: x coord of point2
    - y1: y coord of point1
    - y2: y coord of point2

    Returns:
    - True/False
    - intersection position (with 3 coords, for compatibility)
    """
    # Define variables
    x, y, t= symbols('x y t')
    # Equation of the circle centered at the origin
    line_equation = Eq(x, 0)
    # Parametric equations of the line segment
    segment_x = x1 + (x2 - x1) * t
    segment_y = y1 + (y2 - y1) * t
    # Substitute parametric equations into the circle equation
    line_intersection = line_equation.subs({x: segment_x, y: segment_y})
    # Solve the resulting quadratic equation for t
    intersection_points = solve(line_intersection, t)
    #print("Curvilinear abscissa: ", intersection_points)
    if (len(intersection_points)==0):
        return [False, np.array([0.0,0.0,0.0])]
       # Evaluate the parametric equations at the intersection points
    intersection_coordinates = \
       [(segment_x.subs(t, point), segment_y.subs(t, point)) for point in intersection_points]
    #print ("Intersection points: ", intersection_coordinates)
    if (is_proper(intersection_points[0])):
        #print ("it's the first")
        point = intersection_coordinates[0]
        return [True, np.array([point[0], point[1],0.0])]
    else:
        return [False, np.array([0.0,0.0,0.0])]

# check if face is cut
def is_cut(mesh,ifa,rho):
    """
    checks if face is intersected by disk with radius rho
    """
    r_min = 1e6
    r_max = 0
    for ino in range(3):
        r = np.linalg.norm(mesh.coords[mesh.faces[ifa,ino]])
        if (r<=r_min):
            r_min = r
        if (r>=r_max):
            r_max = r
    if (r_min<=rho and rho<=r_max):
        return True
        
# check if face is cut
def is_cut_1D(mesh,ifa):
    """
    checks if face is intersected by line x=0
   """
    x_min =  1e6
    x_max = -1e6
    for ino in range(3):
        x = mesh.coords[mesh.faces[ifa,ino],0]
        if (x<=x_min):
            x_min = x
        if (x>=x_max):
            x_max = x
    if (x_min<=0 and x_max>=0):
        return True

# check if point is present
def check_if_present(mesh,node_coords):
   for ino in range(mesh.Npoints):
        diff = node_coords-mesh.coords[ino]
        if (np.dot(diff,diff)<1e-10):
            #print ("Point already there")
            return [True, ino]
   return [False, -1]

def split_face(mesh,ifa,rho):
    inters_mask = [0,0,0] #Pattern of intersections to get orientation (if counter_clock)
    vert_mask   = [0,0,0] #Pattern of vertices for orientation (increase if side is cut)
    inters_found = 0
    int1 = -1             #idx intersection
    int2 = -1
    # Loop over Edges to find intersection
    for ie in range(3):
        ino1 = mesh.faces[ifa,ie]
        ino2 = mesh.faces[ifa, (ie+1)%3]
        point1 = mesh.coords[ino1,:]
        point2 = mesh.coords[ino2,:]
        [cut, int_coords] = calc_intersection(point1[0], point2[0], point1[1],point2[1],rho)
        int_coords = int_coords.astype(float)
        if cut:
            # Add point if not already there
            [present, idx] = check_if_present (mesh,int_coords)
            if (not present):
                mesh.Npoints = mesh.Npoints + 1
                mesh.coords = np.vstack([mesh.coords,np.array([int_coords[0], int_coords[1], 0.0])])
                idx = mesh.Npoints-1
            # Mark index
            if (inters_found == 0):
                int1 = idx
                inters_found = inters_found + 1
            else:
                int2 = idx
            # Update Vert mask
            vert_mask [ie] = vert_mask[ie] + 1
            vert_mask [(ie+1)%3] = vert_mask [(ie+1)%3] + 1
            # Update inters_mask
            inters_mask[ie] = 1
    # Get index of vertices in the right order
    vert_mask = np.array(vert_mask)
    loc_v1 = np.where(vert_mask == 2)[0][0]
    #print ("vertex mask: ", vert_mask)
    #print ("inters_mask: ", inters_mask)
    #print("pos of v1: ",loc_v1)
    v1 = mesh.faces[ifa,loc_v1]
    v2 = mesh.faces[ifa,(loc_v1+1)%3]
    v3 = mesh.faces[ifa,(loc_v1+2)%3]
    # Put intersection in right order
    if (inters_mask==[1,1,0] or inters_mask==[0,1,1]):
        int_prec = int1
        int_fol  = int2
    else:
        int_prec = int2
        int_fol  = int1
    # Define list of ordered vertices of new elements (the triangle first)
    # Notice that cut edge is the first
    l1 = [int_fol,int_prec,v1,-1]
    l2 = [int_prec,int_fol,v2,v3]
    return [l1,l2]
    
def split_face_1D(mesh,ifa):
    inters_mask = [0,0,0] #Pattern of intersections to get orientation (if counter_clock)
    vert_mask   = [0,0,0] #Pattern of vertices for orientation (increase if side is cut)
    inters_found = 0
    int1 = -1             #idx intersection
    int2 = -1
    # Loop over Edges to find intersection
    for ie in range(3):
        ino1 = mesh.faces[ifa,ie]
        ino2 = mesh.faces[ifa, (ie+1)%3]
        point1 = mesh.coords[ino1,:]
        point2 = mesh.coords[ino2,:]
        [cut, int_coords] = calc_intersection_1D(point1[0], point2[0], point1[1],point2[1])
        int_coords = int_coords.astype(float)
        if cut:
            # Add point if not already there
            [present, idx] = check_if_present (mesh,int_coords)
            if (not present):
                mesh.Npoints = mesh.Npoints + 1
                mesh.coords = np.vstack([mesh.coords,np.array([int_coords[0], int_coords[1], 0.0])])
                mesh.bnd_mask=np.append(mesh.bnd_mask,-1)
                idx = mesh.Npoints-1
            # Mark index
            if (inters_found == 0):
                int1 = idx
                inters_found = inters_found + 1
            else:
                int2 = idx
            # Update Vert mask
            vert_mask [ie] = vert_mask[ie] + 1
            vert_mask [(ie+1)%3] = vert_mask [(ie+1)%3] + 1
            # Update inters_mask
            inters_mask[ie] = 1
    # Get index of vertices in the right order
    vert_mask = np.array(vert_mask)
    loc_v1 = np.where(vert_mask == 2)[0][0]
    #print ("vertex mask: ", vert_mask)
    #print ("inters_mask: ", inters_mask)
    #print("pos of v1: ",loc_v1)
    v1 = mesh.faces[ifa,loc_v1]
    v2 = mesh.faces[ifa,(loc_v1+1)%3]
    v3 = mesh.faces[ifa,(loc_v1+2)%3]
    # Put intersection in right order
    if (inters_mask==[1,1,0] or inters_mask==[0,1,1]):
        int_prec = int1
        int_fol  = int2
    else:
        int_prec = int2
        int_fol  = int1
    # Define list of ordered vertices of new elements (the triangle first)
    # Notice that cut edge is the first
    l1 = [int_fol,int_prec,v1,-1]
    l2 = [int_prec,int_fol,v2,v3]
    return [l1,l2]


def barycenter (mesh,ifa):
    node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
    x_T = np.zeros(3)
    for ino in range(node_per_face):
        x_T = x_T + mesh.coords[mesh.faces[ifa,ino],:]
    return x_T/node_per_face

def calc_surface(mesh,ifa):
    #shoelace formula
    mod_F = 0
    node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
    for ino in range(node_per_face):
        x1 = mesh.coords[mesh.faces[ifa,ino],0]
        y1 = mesh.coords[mesh.faces[ifa,ino],1]
        x2 = mesh.coords[mesh.faces[ifa,(ino+1)%node_per_face],0]
        y2 = mesh.coords[mesh.faces[ifa,(ino+1)%node_per_face],1]
        mod_F = mod_F + x1*y2 - x2*y1
    mod_F = 0.5*mod_F
    return mod_F

def simpson (a, b, fun, with_s = False, sign = 'plus'):
    # a, b: points in 2D space (np arrays)
    # fun: real function with double argument
    mid1 = a + (b-a)/4
    mid2 = a + (b-a)*2/4
    mid3 = a + (b-a)*3/4
    if   (with_s and sign =='minus'):
        return  np.linalg.norm(b-a)/90*(7*fun(a[0], a[1]) +
                                        24*fun(mid1[0],mid1[1]) +
                                        6*fun(mid2[0],mid2[1]) +
                                        8*fun(mid3[0],mid3[1]))
    elif (with_s and sign =='plus'):
        return  np.linalg.norm(b-a)/90*(8*fun(mid1[0],mid1[1]) +
                                        6*fun(mid2[0],mid2[1]) +
                                       24*fun(mid3[0],mid3[1]) +
                                        7*fun(b[0], b[1]))
    else:
        return  np.linalg.norm(b-a)/90*(7*fun(a[0], a[1]) +
                                        32*fun(mid1[0],mid1[1]) +
                                        12*fun(mid2[0],mid2[1]) +
                                        32*fun(mid3[0],mid3[1]) +
                                        7*fun(b[0], b[1]))

def break_mesh(mesh,rho):
    """
    Breaks elements cut by the disk. In particular:
    - generates new points and appends them to coords
    - generates new elements and appends them to faces
    - masks elements that are cut and are no more elements of the new mesh

    Input:
    - mesh: Mesh instance
    - rho: disk radius

    CONVENTION FOR CONNECTIVITY:
    - generated points appended
    - generated faces appended
    - cut_faces[ifa] = 0 ==> ifa is not intersected
    - cut faces[ifa] = 1 ==> ifa is intersected and deactivated
    - cut_faces[ifa] = 2 ==> ifa is generated by brek_mesh and may not be a triangle
                         ==> faces[ifa,0:1] are generated points
    """
    for ifa in range(mesh.Nfaces_init):
        #Check if face is cut by circle
        if (is_cut(mesh,ifa,rho)):
            #print ("Face: ", ifa)
            # Mask the Face
            mesh.cut_faces[ifa] = 1
            # Create new nodes and faces
            [f1,f2] = split_face(mesh,ifa,rho)
            #print (f1,f2)
            # Update list of faces and mask
            mesh.faces = np.vstack([mesh.faces,np.array(f1)])
            mesh.faces = np.vstack([mesh.faces, np.array(f2)])
            mesh.cut_faces=np.append(mesh.cut_faces,2)
            mesh.cut_faces=np.append(mesh.cut_faces,2)
            mesh.Nfaces = mesh.Nfaces + 2
            # Update mesh.side_mask
            mesh.side_mask=np.append(mesh.side_mask,-1)
            mesh.side_mask=np.append(mesh.side_mask,-1)
            if (np.linalg.norm(barycenter(mesh,mesh.Nfaces-2))<rho):
                mesh.side_mask[mesh.Nfaces-2] = 0
            else:
                mesh.side_mask[mesh.Nfaces-2] = 1
            if (np.linalg.norm(barycenter(mesh,mesh.Nfaces-1))<rho):
                mesh.side_mask[mesh.Nfaces-1] = 0
            else:
                mesh.side_mask[mesh.Nfaces-1] = 1
            # Update gamma_edge (first element is the internal)
            if (mesh.gamma_edges.size==0):
                if (mesh.side_mask[mesh.Nfaces-2]==0):
                        mesh.gamma_edges = np.array([mesh.Nfaces-2, mesh.Nfaces-1])
                else:
                        mesh.gamma_edges = np.array([mesh.Nfaces-1, mesh.Nfaces-2])
            else:
                if (mesh.side_mask[mesh.Nfaces-2]==0):
                        mesh.gamma_edges = np.vstack([mesh.gamma_edges, np.array([mesh.Nfaces-2, mesh.Nfaces-1])])
                else:
                        mesh.gamma_edges = np.vstack([mesh.gamma_edges, np.array([mesh.Nfaces-1, mesh.Nfaces-2])])
        elif (np.linalg.norm(barycenter(mesh,ifa))<rho):
            mesh.side_mask[ifa] = 0
        else:
            mesh.side_mask[ifa] = 1
    # Update number of deegrees of freedom
    mesh.Ndof = mesh.Npoints_init + 2*(mesh.Npoints-mesh.Npoints_init)
            
def mark_bnd_points(mesh):
    # boundary mask, code:
    # 0: internal
    # 1: x=-0.5
    # 2: y=-0.5
    # 3: x= 0.5
    # 4: y= 0.5
    for ino in range(mesh.Npoints):
        if (abs(mesh.coords[ino,0]+0.5)<1e-6):
            mesh.bnd_mask[ino]= 1
        if (abs(mesh.coords[ino,1]+0.5)<1e-6):
            mesh.bnd_mask[ino] = 2
        if (abs(mesh.coords[ino,0]-0.5)<1e-6):
            mesh.bnd_mask[ino] = 3
        if (abs(mesh.coords[ino,1]-0.5)<1e-6):
            mesh.bnd_mask[ino] = 4
            
    
def break_mesh_1D(mesh):
    """
    Breaks elements cut by line x=0. In particular:
    - generates new points and appends them to coords
    - generates new elements and appends them to faces
    - masks elements that are cut and are no more elements of the new mesh

    Input:
    - mesh: Mesh instance

    CONVENTION FOR CONNECTIVITY:
    - generated points appended
    - generated faces appended
    - cut_faces[ifa] = 0 ==> ifa is not intersected
    - cut faces[ifa] = 1 ==> ifa is intersected and deactivated
    - cut_faces[ifa] = 2 ==> ifa is generated by brek_mesh and may not be a triangle
                         ==> faces[ifa,0:1] are generated points
    """
    for ifa in range(mesh.Nfaces_init):
        #Check if face is cut by circle
        if (is_cut_1D(mesh,ifa)):
            #print ("Face: ", ifa)
            # Mask the Face
            mesh.cut_faces[ifa] = 1
            # Create new nodes and faces
            [f1,f2] = split_face_1D(mesh,ifa)
            #print (f1,f2)
            # Update list of faces and mask
            mesh.faces = np.vstack([mesh.faces,np.array(f1)])
            mesh.faces = np.vstack([mesh.faces, np.array(f2)])
            mesh.cut_faces=np.append(mesh.cut_faces,2)
            mesh.cut_faces=np.append(mesh.cut_faces,2)
            mesh.Nfaces = mesh.Nfaces + 2
            # Update mesh.side_mask
            mesh.side_mask=np.append(mesh.side_mask,-1)
            mesh.side_mask=np.append(mesh.side_mask,-1)
            if (barycenter(mesh,mesh.Nfaces-2)[0]<0):
                mesh.side_mask[mesh.Nfaces-2] = 0
            else:
                mesh.side_mask[mesh.Nfaces-2] = 1
            if (barycenter(mesh,mesh.Nfaces-1)[0]<0):
                mesh.side_mask[mesh.Nfaces-1] = 0
            else:
                mesh.side_mask[mesh.Nfaces-1] = 1
            # Update gamma_edge (first element is the internal)
            if (mesh.gamma_edges.size==0):
                if (mesh.side_mask[mesh.Nfaces-2]==0):
                        mesh.gamma_edges = np.array([mesh.Nfaces-2, mesh.Nfaces-1])
                else:
                        mesh.gamma_edges = np.array([mesh.Nfaces-1, mesh.Nfaces-2])
            else:
                if (mesh.side_mask[mesh.Nfaces-2]==0):
                        mesh.gamma_edges = np.vstack([mesh.gamma_edges, np.array([mesh.Nfaces-2, mesh.Nfaces-1])])
                else:
                        mesh.gamma_edges = np.vstack([mesh.gamma_edges, np.array([mesh.Nfaces-1, mesh.Nfaces-2])])
        elif (barycenter(mesh,ifa)[0]<0):
            mesh.side_mask[ifa] = 0
        else:
            mesh.side_mask[ifa] = 1
    # Update number of deegrees of freedom
    mesh.Ndof = mesh.Npoints_init + 2*(mesh.Npoints-mesh.Npoints_init)

# Discrete Gradient Matrix (dimSpace(=2) ,node_per_face)
def GR (mesh,ifa):
    node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
    GRAD = np.zeros((2, node_per_face))
    for ino in range(node_per_face):
        start1 = end2 = np.array(mesh.coords[mesh.faces[ifa][ino],0:2]) #dx
        start2 = np.array(mesh.coords[mesh.faces[ifa,(ino-1)%node_per_face], 0:2])
        end1   = np.array(mesh.coords[mesh.faces[ifa,(ino+1)%node_per_face], 0:2])
        tangent1 = (end1-start1)
        tangent2 = (end2-start2)
        # get normal by rotation
        normal1 = np.array([[0,1],[-1,0]])@tangent1
        normal2 = np.array([[0,1],[-1,0]])@tangent2
        norm1 = normal1/np.linalg.norm(normal1)
        norm2 = normal2/np.linalg.norm(normal2)
        mod_F = calc_surface(mesh,ifa)
        GRAD[:,ino] = 0.5/mod_F*(normal1+normal2)
    return GRAD

# Potential RECONSTRUCTION matrix (node_per_face, node_per_face)
def recpot (mesh,ifa):
  node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
  dim_basis     = 3 #dimension of basis of R,c2(T)
  V = np.zeros ((node_per_face, dim_basis)) #evaluation matrix
  M = np.zeros ((dim_basis, dim_basis))     #the mass matrix to invert
  B1 = np.zeros ((dim_basis,node_per_face))  #the rhs matrix (part 1)
  B2 = np.zeros ((dim_basis,node_per_face))  #the rhs matrix (part 2)
  x_T = barycenter(mesh,ifa)
  #define the psi_i (for edge contribution of B)
  psi = [None for _ in range(dim_basis)]
  psi [0] = lambda x,y:  np.array([x-x_T[0],y-x_T[1]])
  psi [1] = lambda x,y:  np.array([x-x_T[0],y-x_T[1]])*(x-x_T[0])
  psi [2] = lambda x,y:  np.array([x-x_T[0],y-x_T[1]])*(y-x_T[1])
  #define the phi_i (for V)
  phi = [None for _ in range(dim_basis)]
  phi [0] = lambda x,y: 2.
  phi [1] = lambda x,y: 3*(x - x_T[0])
  phi [2] = lambda x,y: 3*(y - x_T[1])
  #define the csi_ij (integrated phi_i*phi_j, for M)
  csi = [[None for _ in range(dim_basis)] for _ in range (dim_basis)]
  csi [0][0] = lambda x,y: np.array([2*(x-x_T[0]),
                                       2*(y-x_T[1])])
  csi [0][1] = csi[1][0] = lambda x,y: np.array([0.,
                                                   6*(y-x_T[1])*(x-x_T[0])])
  csi [0][2] = csi[2][0] = lambda x,y: np.array([6*(x-x_T[0])*(y-x_T[1]),
                                                   0.])
  csi [1][1] = lambda x,y: np.array([0.,
                                       9*(y-x_T[1])*((x-x_T[0])**2)])
  csi [1][2] = csi[2][1] = lambda x,y: np.array([(9/4)*((x-x_T[0])**2)*(y-x_T[1]),
                                                   (9/4)*(x-x_T[0])*((y-x_T[1])**2)])
  csi [2][2] = lambda x,y: np.array([9*(x-x_T[0])*((y-x_T[1])**2),
                                       0.])
  #define the chi_iN  (for cell contribution in B)
  chi_fac = [None for _ in range (dim_basis)]
        #visualization
        #if (t == -1):
        #  fig,ax = plt.subplots(figsize=(4,4))
         #   plt.gca().set_aspect('equal', adjustable='box')
          #  start1 = end2 = np.array(nodes[elements[t][j]]) #dx
           # start2 = np.array(nodes[elements[t][(j-1)%node_per_elem]]) #sx
            #end1 = np.array(nodes[elements[t][(j+1)%node_per_elem]])
           # ax.plot([start1[0], end1[0]], [start1[1], end1[1]],'r')
           # ax.plot([start2[0], end2[0]], [start2[1], end2[1]],'r')
            #ax.plot ([start1[0],start1[0]+ e_avg[0] ],
             #        [start1[1],start1[1]+ e_avg[1]])
  chi_fac[0] = lambda  x,y: np.array([(x-x_T[0])*(y-x_T[1]),
                                        (x-x_T[0])*(y-x_T[1])])
  chi_fac[1] = lambda  x,y: np.array([0.5*((x-x_T[0])**2)*(y-x_T[1]),
                                        (y-x_T[1])*((x-x_T[0])**2)])
  chi_fac[2] = lambda  x,y: np.array([(x-x_T[0])*((y-x_T[1])**2),
                                        0.5*((y-x_T[1])**2)*(x-x_T[0])])
  #fill V
  for i in range(node_per_face):
        xx = mesh.coords[mesh.faces[ifa][i]][0]
        yy = mesh.coords[mesh.faces[ifa][i]][1]
        for j in range(dim_basis):
            V[i][j] = phi[j](xx,yy)
    #fill M
  for i in range (dim_basis):
        for j in range (dim_basis):
            #must sum integrals over E of csi*n
            for k in range(node_per_face):
                # get direction of edge
                start = mesh.coords[mesh.faces[ifa][k], 0:2]
                end   = mesh.coords[mesh.faces[ifa][(k+1)%node_per_face], 0:2]
                tangent = (end-start)/np.linalg.norm(end-start)
                # get normal by rotation
                normal = np.array([[0,1],[-1,0]])@tangent
                M [i][j] = M [i][j] + simpson(start, end, lambda x,y: np.dot(normal,csi[i][j] (x,y)))
  #fill B
  for i in range(dim_basis):
        for j in range (node_per_face):
                #face contribution form left and right (need 2 normals)
                start1 = end2 = np.array(mesh.coords[mesh.faces[ifa][j],0:2]) #dx
                start2 = np.array(mesh.coords[mesh.faces[ifa][(j-1)%node_per_face], 0:2]) #sx
                end1   = np.array(mesh.coords[mesh.faces[ifa][(j+1)%node_per_face], 0:2])
                tangent1 = (end1-start1)
                tangent2 = (end2-start2)
                # get normal by rotation
                normal1 = np.array([[0,1],[-1,0]])@tangent1
                normal2 = np.array([[0,1],[-1,0]])@tangent2
                norm1 = normal1/np.linalg.norm(normal1)
                norm2 = normal2/np.linalg.norm(normal2)
                B2 [i][j] = B2 [i][j] + simpson(start1, end1,
                                              lambda x,y: np.dot(norm1,psi[i](x,y)), True, 'minus')#dx
                B2 [i][j] = B2 [i][j] + simpson(start2, end2,
                                              lambda x,y: np.dot(norm2,psi[i](x,y)), True, 'plus')#sx
                #cell contribution: must sum integrals over E of chi*n
                e_avg = 0.5*(normal1 + normal2)
                chi_ij = lambda x,y: np.multiply (np.flip(e_avg), chi_fac[i](x,y))
                for k in range(node_per_face):
                    start = mesh.coords[mesh.faces[ifa][k],0:2]
                    end = mesh.coords[mesh.faces[ifa][(k+1)%node_per_face], 0:2]
                    tangent = (end-start)/np.linalg.norm(end-start)
                    # get normal by rotation
                    normal = np.array([[0,1],[-1,0]])@tangent
                    # get surface of face
                    mod_F = calc_surface (mesh,ifa)
                    B1[i][j] = B1[i][j] -(1/mod_F)* simpson(start, end, lambda x,y: np.dot(normal,chi_ij(x,y)))
  #calculate the final local matrix S an store it
  R = np.dot(V, np.linalg.solve(M,(B1+B2)))
  return R

# Convention: internal unknowns, intface unknowns side in, intface unknowns side ex
def glob_idx (mesh,ifa,ino):
    idx_point = mesh.faces[ifa,ino]
    if (idx_point<mesh.Npoints_init):
    # point is from the original mesh: not on the int.face
        return idx_point
    else:
    # interface point, doubled: unknown structure:
    # [internal unknowns, internal intface unk, external intface unknowns]
        side = mesh.side_mask[ifa]
        if (side==0):
            return mesh.Npoints_init + (idx_point-mesh.Npoints_init)
        elif (side==1):
            #return Npoints_init +(Npoints-Npoints_init)+(idx_point-Npoints_init)
            return idx_point + (mesh.Npoints-mesh.Npoints_init)
        else:
            print ("Error: this face is cut")

# Kronecker Delta
def kron(i,j):
    if (i==j):
        return 1
    else:
        return 0

def assemble_M_gamma(mesh,sigma_in,sigma_ex):
    # Matrix M_gamma (jump of gradient)
    M_gamma = np.zeros((mesh.Ndof,mesh.Ndof))
    for ied in range(mesh.gamma_edges.shape[0]):
        # table of dofs touched by the edge
        # 7 dofs: 3 from the triangle + 4 from the quad
        edge_dofs = np.zeros((7,2),dtype=int)
        ifa_in = mesh.gamma_edges[ied,0]
        ifa_ex = mesh.gamma_edges[ied,1]
        node_per_face_in = np.count_nonzero(mesh.faces[ifa_in,:] != -1)
        node_per_face_ex = np.count_nonzero(mesh.faces[ifa_ex,:] != -1)
        # dofs ifa_in
        for ino_in in range(node_per_face_in):
            edge_dofs[ino_in,0] = glob_idx(mesh,ifa_in, ino_in)
            edge_dofs[ino_in,1] = ifa_in
        # dofs ifa_ex
        for ino_ex in range(node_per_face_ex):
            edge_dofs[node_per_face_in+ino_ex,0] = glob_idx(mesh,ifa_ex, ino_ex)
            edge_dofs[node_per_face_in+ino_ex,1] = ifa_ex
        for idof1 in range(7):
            dof1 = edge_dofs[idof1,0] #global idx
            if (idof1<node_per_face_in): #local idx
                dof1_loc = idof1
            else:
                dof1_loc = idof1-node_per_face_in
            ifa1 = edge_dofs[idof1,1] #idx of face$
            GR1 = GR(mesh,ifa1)
            sigma1 = sigma_in*int(ifa1==ifa_in) + sigma_ex*int(ifa1==ifa_ex)
            tangent = mesh.coords[mesh.faces[ifa1,1],0:2]-mesh.coords[mesh.faces[ifa1,0],0:2]
            sign1 = int(ifa1==ifa_in)-int(ifa1==ifa_ex)
            normal = sign1*np.array([[0,1],[-1,0]])@tangent
            #normal = normal/np.linalg.norm(normal)
            mean_sigma_grad_normal = 0.5*sigma1*np.dot(GR1[:,dof1_loc],normal)
            for idof2 in range(7):
                dof2 = edge_dofs[idof2,0] #global idx
                if (idof2<node_per_face_in): #local idx
                    dof2_loc = idof2
                else:
                    dof2_loc = idof2-node_per_face_in
                ifa2 = edge_dofs[idof2,1]
                R2 = recpot(mesh,ifa2)
                ## Setting node prec as first vertex and node post as second
                ## should be indifferent though
                node_per_face_2 = np.count_nonzero(mesh.faces[ifa2,:] != -1)
                if (node_per_face_2 ==4):
                    v2A = R2[0,dof2_loc]
                    v2B = R2[1,dof2_loc]
                else:
                    v2A = R2[1,dof2_loc]
                    v2B = R2[0,dof2_loc]
                # sign (jump must be ex-in)
                sign2 = int(ifa2==ifa_ex)-int(ifa2==ifa_in)
                ## integral
                jump_of_rec = 0.5*(v2A+v2B)*sign2
                M_gamma[dof1,dof2] = M_gamma[dof1,dof2] + mean_sigma_grad_normal*jump_of_rec
    return M_gamma


def assemble_G(mesh,sigma_in,sigma_ex):
    # Assemble matrix G (grad-grad)
    G = np.zeros((mesh.Ndof,mesh.Ndof))
    for ifa in range(mesh.Nfaces):
        side = mesh.side_mask[ifa]
        if (mesh.cut_faces[ifa] != 1):
            node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
            GRAD = GR(mesh,ifa)
            mod_F = calc_surface(mesh,ifa)
            sigma = (1-side)*sigma_in + side*sigma_ex
            for i in range(node_per_face):
                for j in range(node_per_face):
                    glob_i = glob_idx(mesh,ifa,i)
                    glob_j = glob_idx(mesh,ifa,j)
                    G[glob_i,glob_j] = G[glob_i,glob_j] +sigma*mod_F*np.dot(GRAD[:,i],GRAD[:,j])
    return G
    
def assemble_G_no_sigma(mesh):
    # Assemble matrix G_no_sigma (to calculate H1 like norm)
    G = np.zeros((mesh.Ndof,mesh.Ndof))
    for ifa in range(mesh.Nfaces):
        side = mesh.side_mask[ifa]
        if (mesh.cut_faces[ifa] != 1):
            node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
            GRAD = GR(mesh,ifa)
            mod_F = calc_surface(mesh,ifa)
            for i in range(node_per_face):
                for j in range(node_per_face):
                    glob_i = glob_idx(mesh,ifa,i)
                    glob_j = glob_idx(mesh,ifa,j)
                    G[glob_i,glob_j] = G[glob_i,glob_j] +mod_F*np.dot(GRAD[:,i],GRAD[:,j])
    return G

def assemble_S(mesh):
    # Assemble matrix S (stabilization)
    S = np.zeros((mesh.Ndof,mesh.Ndof))
    for ifa in range(mesh.Nfaces):
        if (mesh.cut_faces[ifa] != 1):
            node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
            R = recpot(mesh,ifa)
            for i in range(node_per_face):
                for j in range(node_per_face):
                    glob_i = glob_idx(mesh,ifa,i)
                    glob_j = glob_idx(mesh,ifa,j)
                    for k in range (node_per_face):
                        S[glob_i,glob_j] = S[glob_i,glob_j] + (R[k,i]-kron(i,k))*(R[k,j]-kron(j,k))
    return S

# calculate the integral over the [0,1] of the product between 2 affine functions assigned through their
# values at vertices 0 and 1 (first values at 0 of f1 and f2 an then values at 1)
def calc_r2_prod_integ(v1A,v1B,v2A,v2B):
    return v1A*v2A*1/3 + (v1A*v2B+v1B*v2A)*1/6 + v1B*v2B*1/3

def assemble_N_gamma(mesh):
    # matrix N_gamma (jump penalisation)
    N_gamma = np.zeros((mesh.Ndof,mesh.Ndof))
    for ied in range(mesh.gamma_edges.shape[0]):
        # table of dofs touched by the edge
        # 7 dofs: 3 from the triangle + 4 from the quad
        edge_dofs = np.zeros((7,2),dtype=int)
        ifa_in = mesh.gamma_edges[ied,0]
        ifa_ex = mesh.gamma_edges[ied,1]
        node_per_face_in = np.count_nonzero(mesh.faces[ifa_in,:] != -1)
        node_per_face_ex = np.count_nonzero(mesh.faces[ifa_ex,:] != -1)
        # dofs ifa_in
        for ino_in in range(node_per_face_in):
            edge_dofs[ino_in,0] = glob_idx(mesh,ifa_in, ino_in)
            edge_dofs[ino_in,1] = ifa_in
        # dofs ifa_ex
        for ino_ex in range(node_per_face_ex):
            edge_dofs[node_per_face_in+ino_ex,0] = glob_idx(mesh,ifa_ex, ino_ex)
            edge_dofs[node_per_face_in+ino_ex,1] = ifa_ex
        for idof1 in range(7):
            # get nodal values of reconstruction
            dof1 = edge_dofs[idof1,0] #global idx
            if (idof1<node_per_face_in): #local idx
                dof1_loc = idof1
            else:
                dof1_loc = idof1-node_per_face_in
            ifa1 = edge_dofs[idof1,1]
            R1 = recpot(mesh,ifa1)
            ## convention: node1 is prec, node2 is post:
            ## to distinguish must understand what face I'm on,
            ## the 4-verticed one or the the 3-verticed one
            node_per_face_1 = np.count_nonzero(mesh.faces[ifa1,:] != -1)
            if (node_per_face_1 ==4):
                v1A = R1[0,dof1_loc]
                v1B = R1[1,dof1_loc]
            else:
                v1A = R1[1,dof1_loc]
                v1B = R1[0,dof1_loc]
            # sign (jump must be ex-in)
            sign1 = int(ifa1==ifa_ex)-int(ifa1==ifa_in)
            for idof2 in range(7):
                dof2 = edge_dofs[idof2,0] #global idx
                if (idof2<node_per_face_in): #local idx
                    dof2_loc = idof2
                else:
                    dof2_loc = idof2-node_per_face_in
                ifa2 = edge_dofs[idof2,1]
                R2 = recpot(mesh,ifa2)
                # ATTENTION: important detail
                # the order of intface nodes for genrated elements is pos//prec for the one
                # with 3 vertices and prec//pos for the one with 4 vertices (mind the inversion)
                node_per_face_2 = np.count_nonzero(mesh.faces[ifa2,:] != -1)
                if (node_per_face_2 ==4):
                    v2A = R2[0,dof2_loc]
                    v2B = R2[1,dof2_loc]
                else:
                    v2A = R2[1,dof2_loc]
                    v2B = R2[0,dof2_loc]
                # sign (jump must be ex-in)
                sign2 = int(ifa2==ifa_ex)-int(ifa2==ifa_in)
                # contribution
                ## edge length
                mod_E = np.linalg.norm(mesh.coords[mesh.faces[ifa2,0],:]-mesh.coords[mesh.faces[ifa2,1],:])
                ## integral
                local_contrib = calc_r2_prod_integ(v1A,v1B,v2A,v2B)
                N_gamma[dof1,dof2] = N_gamma[dof1,dof2] + mod_E*sign1*sign2*local_contrib
    return N_gamma

def assemble_b_phi(mesh,phi_datum):
    b_phi = np.zeros((mesh.Ndof))
    for ied in range(mesh.gamma_edges.shape[0]):
        # table of dofs touched by the edge
        # 7 dofs: 3 from the triangle + 4 from the quad
        edge_dofs = np.zeros((7,2),dtype=int)
        ifa_in = mesh.gamma_edges[ied,0]
        ifa_ex = mesh.gamma_edges[ied,1]
        node_per_face_in = np.count_nonzero(mesh.faces[ifa_in,:] != -1)
        node_per_face_ex = np.count_nonzero(mesh.faces[ifa_ex,:] != -1)
        # dofs ifa_in
        for ino_in in range(node_per_face_in):
            edge_dofs[ino_in,0] = glob_idx(mesh,ifa_in, ino_in)
            edge_dofs[ino_in,1] = ifa_in
        # dofs ifa_ex
        for ino_ex in range(node_per_face_ex):
            edge_dofs[node_per_face_in+ino_ex,0] = glob_idx(mesh,ifa_ex, ino_ex)
            edge_dofs[node_per_face_in+ino_ex,1] = ifa_ex
        for idof in range(7):
            # get nodal values of reconstruction
            dof = edge_dofs[idof,0] #global idx
            if (idof<node_per_face_in): #local idx
                dof_loc = idof
            else:
                dof_loc = idof-node_per_face_in
            ifa = edge_dofs[idof,1]
            R = recpot(mesh,ifa)
            # vertex 1 = node prec
            node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
            if (node_per_face ==4):
                v1A = R[0,dof_loc]
                v1B = R[1,dof_loc]
            else:
                v1A = R[1,dof_loc]
                v1B = R[0,dof_loc]
            # get nodal values of phi_datum
            # vertex 1 = node prec
            if (node_per_face ==4):
                ino1 = mesh.faces[ifa,0]
                ino2 = mesh.faces[ifa,1]
            else:
                ino1 = mesh.faces[ifa,1]
                ino2 = mesh.faces[ifa,0]
            ## attention: indexes are shifted
            xA = mesh.coords[ino1,0]
            yA = mesh.coords[ino1,1]
            xB = mesh.coords[ino2,0]
            yB = mesh.coords[ino2,1]
            v2A = phi_datum(xA,yA)
            v2B = phi_datum(xB,yB)
            #print (v1A, v1B)
            ## edge length
            mod_E = np.linalg.norm(mesh.coords[mesh.faces[ifa,0],:]-mesh.coords[mesh.faces[ifa,1],:])
            # sign (jump must be ex-in)
            sign = int(ifa==ifa_ex)-int(ifa==ifa_in)
            # local contribution
            local_contrib = calc_r2_prod_integ(v1A,v1B,v2A,v2B)
            # integral
            b_phi[dof] = b_phi[dof] + mod_E*sign*local_contrib
    return b_phi

def visualize_mesh(mesh,rho):
    fig, ax = plt.subplots(figsize=(20,20))
    for ifa in range(mesh.Nfaces):
        if (mesh.cut_faces[ifa]!=1):
            if (mesh.faces[ifa,3]==-1):
                nvert = 3
            else:
                nvert = 4
            for ino in range(nvert):
               p1 = mesh.coords[mesh.faces[ifa,ino],:]
               p2 = mesh.coords[mesh.faces[ifa,(ino+1)%nvert],:]
               dx = p2-p1
               xx = [p1[0],p2[0]]
               yy = [p1[1],p2[1]]
               if (mesh.cut_faces[ifa]==0 or mesh.cut_faces[ifa]==1):
                  ax.plot(xx,yy,'k', linewidth=0.1)
               if (mesh.cut_faces[ifa]==2 and nvert ==3):
                   ax.plot(xx,yy,'r', linewidth=1)
               if (mesh.cut_faces[ifa]==2 and nvert ==4):
                  ax.plot(xx,yy,'b', linewidth=1)
            circle = plt.Circle((0, 0), radius=rho, edgecolor='g', facecolor='none')
            ax.add_patch(circle)
    # mark generated points
    for ino in range(mesh.Npoints):
        if (ino>=mesh.Npoints_init):
            xx = mesh.coords[ino,0]
            yy = mesh.coords[ino,1]
            point = ax.scatter(xx,yy,color='green')
    # mark mesh.faces according to side
    for ifa in range(mesh.Nfaces):
        if (mesh.cut_faces[ifa]!=1):
            p = barycenter(mesh,ifa)
            xx = p[0]
            yy = p[1]
            if (mesh.side_mask[ifa]==0):
                point = ax.scatter(xx,yy,color='orange')
            else:
                point = ax.scatter(xx,yy,color='violet')
                
def visualize_mesh_1D(mesh):
    fig, ax = plt.subplots(figsize=(20,20))
    for ifa in range(mesh.Nfaces):
        if (mesh.cut_faces[ifa]!=1):
            if (mesh.faces[ifa,3]==-1):
                nvert = 3
            else:
                nvert = 4
            for ino in range(nvert):
               p1 = mesh.coords[mesh.faces[ifa,ino],:]
               p2 = mesh.coords[mesh.faces[ifa,(ino+1)%nvert],:]
               dx = p2-p1
               xx = [p1[0],p2[0]]
               yy = [p1[1],p2[1]]
               if (mesh.cut_faces[ifa]==0 or mesh.cut_faces[ifa]==1):
                  ax.plot(xx,yy,'k', linewidth=0.1)
               if (mesh.cut_faces[ifa]==2 and nvert ==3):
                   ax.plot(xx,yy,'r', linewidth=1)
               if (mesh.cut_faces[ifa]==2 and nvert ==4):
                  ax.plot(xx,yy,'b', linewidth=1)
            line_x = [0.0, 0.0]
            line_y = [-0.5,0.5]
            ax.plot(line_x,line_y, color='green')
    # mark generated points
    for ino in range(mesh.Npoints):
        if (ino>=mesh.Npoints_init):
            xx = mesh.coords[ino,0]
            yy = mesh.coords[ino,1]
            point = ax.scatter(xx,yy,color='green')
    # mark mesh.faces according to side
    for ifa in range(mesh.Nfaces):
        if (mesh.cut_faces[ifa]!=1):
            p = barycenter(mesh,ifa)
            xx = p[0]
            yy = p[1]
            if (mesh.side_mask[ifa]==0):
                point = ax.scatter(xx,yy,color='orange')
            else:
                point = ax.scatter(xx,yy,color='violet')

# reference solution (takes dof as argument to treat intface nodes)
def reference_solution (mesh, dof, rho, ref_sol_in, ref_sol_ex):
    if (dof<mesh.Npoints):
        point = mesh.coords[dof,:]
    else:
        shift = mesh.Npoints-mesh.Npoints_init
        point = mesh.coords[dof-shift,:]
    # position_code: 0 internal, 1 intface in, 2 intface ex
    on_intface = 0
    if (dof>=mesh.Npoints_init):
        on_intface = 1
    if (dof>=mesh.Npoints):
        on_intface = 2
    radius = np.sqrt(point[0]**2+point[1]**2)
    if (radius<rho and  on_intface==0):
        return ref_sol_in(point[0],point[1])
    if (radius>rho and on_intface==0):
        return ref_sol_ex(point[0],point[1])
    if (on_intface==1):
        return ref_sol_in(point[0],point[1])
    if (on_intface==2):
        return ref_sol_ex(point[0],point[1])
    else:
        print ("Error: something is wrong with point coordinates")
        
# reference solution for 1D solution
def reference_1D_solution (mesh, dof, ref_sol_min, ref_sol_plus):
    if (dof<mesh.Npoints):
        point = mesh.coords[dof,:]
    else:
        shift = mesh.Npoints-mesh.Npoints_init
        point = mesh.coords[dof-shift,:]
    # position_code: 0 internal, 1 intface in, 2 intface ex
    on_intface = 0
    if (dof>=mesh.Npoints_init):
        on_intface = 1
    if (dof>=mesh.Npoints):
        on_intface = 2
    x = point[0]
    if (x<0 and  on_intface==0):
        return ref_sol_min(point[0],point[1])
    if (x>0 and on_intface==0):
        return ref_sol_plus(point[0],point[1])
    if (on_intface==1):
        return ref_sol_min(point[0],point[1])
    if (on_intface==2):
        return ref_sol_plus(point[0],point[1])
    else:
        print ("Error: something is wrong with point coordinates")

def impose_bc(mesh,A,b,u_ref):
    for dof in range(mesh.Ndof):
        if (dof<mesh.Npoints):
            ino = dof
        else:
            ino = dof-(mesh.Npoints-mesh.Npoints_init)
        if (mesh.bnd_mask[ino]>0):
            b[dof] = u_ref(mesh,dof)
            A[dof,:] = 0.0
            A[dof,dof] = 1
    return [A,b]

def calc_L0_error (mesh, u, ref_sol):
    u_ref = np.array([ ref_sol(mesh,dof) for dof in range(mesh.Ndof)])
    err = u - u_ref
    return np.max(np.abs(err))
    
def calc_energy_error (mesh, u, ref_sol, G_no_sigma, N_gamma, S):
    u_ref = np.array([ ref_sol(mesh,dof) for dof in range(mesh.Ndof)])
    err = u - u_ref
    contrib_1 = np.dot(np.dot(G_no_sigma,err),err)
    contrib_2 = np.dot(np.dot(N_gamma,err),err)
    contrib_3 = np.dot(np.dot(S,err),err)
    return np.sqrt(contrib_1+contrib_2+contrib_3)

def plot_solution (mesh,u,elevation,azimuth):
    fig = plt.figure(figsize = (15,15))
    ax  = fig.add_subplot(111, projection='3d')
    ax.view_init(elev=elevation, azim=azimuth)
    for ifa in range(mesh.Nfaces):
        if (mesh.cut_faces[ifa]!=1):
            node_per_face = np.count_nonzero(mesh.faces[ifa,:] != -1)
            u_F = np.zeros(node_per_face)
            xx  = np.zeros(node_per_face)
            yy  = np.zeros(node_per_face)
            for ino in range(node_per_face):
                xx[ino], yy[ino] = mesh.coords[mesh.faces[ifa][ino],0:2]
                radius = np.sqrt((xx[ino]**2+yy[ino]**2))
                u_F[ino] = u[glob_idx(mesh,ifa,ino)]
            surf = ax.plot_trisurf(xx, yy, u_F, cmap=cm.coolwarm)
    plt.show()


def write_VTK_file (mesh, u, filename):
    """
    Writes solution into vtk file
    """
    # remove file if existing
    if os.path.exists(filename):
        os.remove(filename)

    cells = mesh.faces.copy()
    # interface points have to be doubled (have to assign nodally the field u)
    no_intface_points = mesh.Npoints-mesh.Npoints_init
    points = np.concatenate((mesh.coords,mesh.coords[mesh.Npoints_init:mesh.Npoints,:]), axis = 0).copy()
    no_points = points.shape[0]
    # get number of not masked elements
    no_masked_faces = np.count_nonzero(mesh.cut_faces == 1)
    no_cells = mesh.Nfaces-no_masked_faces
    # get no_cells*cell_per_node + no_cells
    noIndicesCells = 0
    for iel in range(mesh.Nfaces):
        if (mesh.cut_faces[iel]!=1):
            node_per_cell = np.count_nonzero(cells[iel,:] != -1)
            noIndicesCells = noIndicesCells + node_per_cell
    noIndicesCells = noIndicesCells + no_cells

    with open(filename, 'w') as vtk_file:
        vtk_file.write("# vtk DataFile Version 3.0\n")
        vtk_file.write("Broken Mesh Solution\n")
        vtk_file.write("ASCII\n")
        vtk_file.write("DATASET UNSTRUCTURED_GRID\n")
        vtk_file.write(f"\nPOINTS {no_points} float\n")

        for ino in range(no_points):
            vtk_file.write(f"{points[ino,0]} {points[ino,1]} {points[ino,2]}\n")

        vtk_file.write(f"\nCELLS {no_cells} {noIndicesCells}\n")

        for iel in range(mesh.Nfaces):
            if (mesh.cut_faces[iel]!=1):
                node_per_cell = np.count_nonzero(cells[iel,:] != -1)
                nodes = cells[iel,:]
                # correct index of node:
                # if element is on interface and external
                # for the inteface node (first two) add Npoint-Npoints_init
                if (mesh.cut_faces[iel]==2):
                    if(mesh.side_mask[iel]==1):
                        nodes[0] = nodes[0] + no_intface_points
                        nodes[1] = nodes[1] + no_intface_points
                if (node_per_cell==3):
                    vtk_file.write(f"{3} {nodes[0]} {nodes[1]} {nodes[2]}\n")
                elif (node_per_cell==4):
                    vtk_file.write(f"{4} {nodes[0]} {nodes[1]} {nodes[2]} {nodes[3]}\n")
                else:
                    print ("ERROR: cell with not allowed number of cells")
                    return

        vtk_file.write(f"\nCELL_TYPES {no_cells}\n")

        # 5: triangle; 9: quad
        for iel in range(mesh.Nfaces):
            if (mesh.cut_faces[iel]!=1):
                node_per_cell = np.count_nonzero(cells[iel,:] != -1)
                if (node_per_cell==3):
                    vtk_file.write("5\n")
                elif (node_per_cell==4):
                    vtk_file.write("9\n")
                else:
                    print ("ERROR: cell with not allowed number of cells")
                    return

        vtk_file.write(f"\nPOINT_DATA {no_points}\n")
        vtk_file.write("SCALARS U float\n")
        vtk_file.write("LOOKUP_TABLE default\n")
        for ino in range(no_points):
            vtk_file.write(f"{u[ino]}\n")


def solve_problem (mesh_filename, solution_filename, rho, ref_sol, sigma_in, sigma_ex, eta, phi_datum):
    """
    Solves an interface problem, given mesh and data.
    Writes solution into vtk file

    Returns:
    -u: solution (np.array)
    -mesh: Mesh object (broken)
    """

    # load mesh
    mesh = load_square_mesh(mesh_filename)
    # move critical points near the interface
    move_critical_points(mesh,rho)
    # break mesh
    break_mesh(mesh, rho)
    # assemble system
    G = assemble_G(mesh, sigma_in,sigma_ex)
    G_no_sigma = assemble_G_no_sigma(mesh)
    S = assemble_S(mesh)
    M_gamma = assemble_M_gamma(mesh,sigma_in,sigma_ex)
    N_gamma = assemble_N_gamma(mesh)
    b_phi = assemble_b_phi(mesh,phi_datum)
    # define system, apply bc conds an solve
    A = G+S+eta*N_gamma-np.transpose(M_gamma) # system matrix
    b = eta*b_phi
    [A, b] = impose_bc(mesh, A, b, ref_sol)
    u = np.linalg.solve(A, b)
    write_VTK_file(mesh, u, solution_filename)
    # calculate error
    err_L0 = calc_L0_error(mesh, u, ref_sol)
    err_energy = calc_energy_error(mesh, u, ref_sol, G_no_sigma, N_gamma, S)
    return [mesh, G, G_no_sigma, S, M_gamma, N_gamma, b_phi, A, b, u, err_L0, err_energy]
    
def solve_problem_1D (mesh_filename, solution_filename, ref_sol, sigma_min, sigma_plus, eta, phi_datum):
    """
    Solves an interface problem, given mesh and data.
    Writes solution into vtk file

    Returns:
    -u: solution (np.array)
    -mesh: Mesh object (broken)
    """

    # load mesh
    mesh = load_square_mesh(mesh_filename)
    # move critical points near the interface
    move_critical_points_1D(mesh)
    # break mesh
    break_mesh_1D(mesh)
    # assign boundaries
    mark_bnd_points(mesh)
    # assemble system
    G = assemble_G(mesh, sigma_min,sigma_plus)
    G_no_sigma = assemble_G_no_sigma(mesh)
    S = assemble_S(mesh)
    M_gamma = assemble_M_gamma(mesh,sigma_min,sigma_plus)
    N_gamma = assemble_N_gamma(mesh)
    b_phi = assemble_b_phi(mesh,phi_datum)
    # define system, apply bc conds an solve
    A = G+S+eta*N_gamma-np.transpose(M_gamma) # system matrix
    b = eta*b_phi
    [A, b] = impose_bc(mesh, A, b, ref_sol)
    u = np.linalg.solve(A, b)
    write_VTK_file(mesh, u, solution_filename)
    # calculate error
    err_L0 = calc_L0_error(mesh, u, ref_sol)
    err_energy = calc_energy_error(mesh, u, ref_sol, G_no_sigma, N_gamma, S)
    return [mesh, G, G_no_sigma, S, M_gamma, N_gamma, b_phi, A, b, u, err_L0, err_energy]
    
    

